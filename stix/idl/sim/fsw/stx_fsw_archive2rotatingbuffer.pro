;+
; :description
;   This routine converts a flat array of stx_fsw_archive_buffer and trigger accumulators
;   to a flat array of stx_fsw_rotatingbuffer structures.
;   The transformation between rotating buffer and archive buffer is lossless; the main difference is that
;   the rotating buffer will contain zero counts, whereas the archive buffer has been compacted.
;   There are no changes applied to the detector numbers; SC format from archive buffer is used for rotating
;   buffer!
;   
; :categories:
;   flight software simulator, conversion
;
; :params:
;   eventlist : in, required, type='stx_sim_detector_eventlist'
;     the temperature-corrected detector eventlist
;
; :keywords:
;   archive_buffer : in, required, type='array of stx_fsw_archive_buffer'
;     a flat array of archive buffer structures
;     
;   trigger_accumulators : in, required, type='stx_fsw_result_livetime'
;     the trigger accumulator structure generated by the flight software
;     simulator of 'same size' as the input flat array of archive buffers
;     
;   t_acc_max : in, optional, type='double', default='11d'
;     this keyword allows specifying the maximum accumulation time in seconds
;     before even an 'under filled' count accumulator is emptied and written
;     to the rotating buffer; this value is only then important when the input
;     data has wide gaps, which have to be filled with zero data in the rotating
;     buffer structure. 
;
; :returns:
;   a flat array or one rotating buffer structure (stx_fsw_rotating_buffer)
;
; :example:
;   number_of_samples = 100
;   
;   ; generate a bunch of random events
;   stixfsw_randomtest, number_of_samples
;   restore, 'idlsave.dat'
;
;   ; convert Gordon's random sequence to a flat array of events
;   eventlist = stx_fsw_convert_rnd_events2eventlist(rnd_events=tableout)
;
;   ; filter events
;   filtered_events = stx_sim_timefilter_eventlist(eventlist.detector_events, triggers_out=triggers_out, T_L=latency_time, T_R=readout_time, event=event)
;
;   ; convert the filtered events and the triggers to lists
;   filtered_eventlist = stx_construct_sim_detector_eventlist(detector_events=filtered_events, start_time=stx_time())
;   trigger_eventlist = stx_construct_sim_detector_eventlist(detector_events=triggers_out, start_time=stx_time())
;
;   ; create a FSW SIM object and run the simulation
;   fsw = obj_new('stx_flight_software_simulator', start_time=stx_time())
;   fsw->process, filtered_eventlist, trigger_eventlist, relative_time_final_event=filtered_events[-1].relative_time
;
;   ; extract the archive buffer and trigger accumulators
;   archive_buffer = fsw.archive_buffer
;   triggers = fsw.livetime
;   
;   ; create the rotating buffer structure
;   rotating_buffer  = stx_fsw_archive2rotatingbuffer(archive_buffer=archive_buffer, trigger_accumulators=triggers)
;
; :history:
;   04-Jul-2015 - Laszlo I. Etesi (FHNW), initial release
;   06-Jul-2015 - Laszlo I. Etesi (FHNW), bugfix: allowing archive_buffer to be of 1-t-bin size
;   22-Jul-2015 - Laszlo I. Etesi (FHNW), updated to use time bin end times as the rotating buffer timestamp
;   13-Aug-2015 - Laszlo I. Etesi (FHNW), allowing to set a start time
;   24-Sep-2015 - Laszlo I. Etesi (FHNW), bugfix: incorrect time comparison lead to counts to be lost
;   18-Dec-2015 - Laszlo I. Etesi (FHNW), bugfix: incorrectly assigning triggers, added failover
;   10-May-2016 - Laszlo I. ETesi (FHNW), minor updates to accomodate structure changes
;- 
function stx_fsw_archive2rotatingbuffer, archive_buffer=archive_buffer, trigger_accumulators=trigger_accumulators, t_acc_max=t_acc_max, start_time=start_time
  ppl_require, in=archive_buffer, type='stx_fsw_archive_buffer*'
  ppl_require, in=trigger_accumulators, type='stx_fsw_triggers*'
  
  ; specify some maximum accumulation time
  default, t_acc_max, 11.0d ; in seconds

  ; extract unique end times
  ; make times floating point to avoid later round-off errors
  rel_end_times = archive_buffer.relative_time_range[1]
  uniq_rel_end_times = rel_end_times[uniq(rel_end_times, bsort(rel_end_times))]
  
  ; calculate possible empty rotating buffer entries due to 
  ; expired max accumulation time with no counts
  ; it's possible that t_diff has size 1 (only one t bin)
  t_diff = uniq_rel_end_times - shift(uniq_rel_end_times, 1)
  if(n_elements(t_diff) gt 1) then t_max_reached_idx = where(t_diff[1:-1] gt t_acc_max, n_t_max_reached) $
  else n_t_max_reached = 0
  
  ; add extra times if neccessary
  if(n_t_max_reached gt 0) then begin
    ; the following lines of code are sanity checks; it must not be possible
    ; that the difference between an extra entry and the subsequent entry is less than t_acc_max
    ; since otherwise the subsequent entry would have counted to the extra entry, thus
    ; the difference between two entries (with an extra entry) must be 2 x t_acc_max
    
    if(where(t_diff[1:-1] gt t_acc_max and t_diff[1:-1] lt t_acc_max * 2.0d) ne -1) then message, 'Illegal time information detected (t_a+1 - t_a > t_acc_max, but < 2 * t_acc_max)'
    
    uniq_rel_end_times = [uniq_rel_end_times, uniq_rel_end_times[t_max_reached_idx] + t_acc_max]
    uniq_rel_end_times = uniq_rel_end_times[bsort(uniq_rel_end_times)]    
  endif
  
  ; create empty rotating buffer structures
  rotating_buffer = replicate({stx_fsw_rotating_buffer}, n_elements(uniq_rel_end_times))

  ; assign times (w/o 'start_time shift')
  rotating_buffer.timestamp = uniq_rel_end_times

  ; make a mapping between the rotating buffer (unique times) and the archive buffer
  ; every RB entry can have N AB entries (1:N)
  ab_rb_time_idx_mapping = value_locate(rotating_buffer.timestamp, archive_buffer.relative_time_range[1])

  ; accumulate the counts (AB to RB)
  ; the loop is used only because the 'direct' array addressing is taking too long
  for index = 0L, n_elements(ab_rb_time_idx_mapping)-1 do begin
     abrbid = ab_rb_time_idx_mapping[index]

    rotating_buffer[abrbid].counts[$
      archive_buffer[index].energy_science_channel,$
      archive_buffer[index].pixel_index, $
      archive_buffer[index].detector_index-1] = archive_buffer[index].counts
  endfor
  
  ; get unique start times
  ; probably unnecessary, it's a cautionary measure, assuming the unique start times go with the unique end times and that there are no overlaps in time
  rel_start_times = archive_buffer.relative_time_range[0]
  uniq_rel_start_times = rel_start_times[uniq(rel_start_times, bsort(rel_start_times))]
  
  ; add trigger accumulators to rotating buffer
  ; correct times (absolute since epoc) to be relative and float
  tr_rb_time_idx_mapping = value_locate(uniq_rel_start_times, trigger_accumulators.relative_time_range[0])
  
  ; just check if we have more than one unassigned mapping and assume it is the first
  if(n_elements(where(tr_rb_time_idx_mapping lt 0)) gt 1) then stop
  if(n_elements(uniq_rel_start_times) ne n_elements(trigger_accumulators.relative_time_range[0])) then stop
  
  ; assign triggers
  ;rotating_buffer[tr_rb_time_idx_mapping].triggers = transpose(trigger_accumulators.data)
  
  ; for the time being, just assign the triggers
  rotating_buffer.triggers = trigger_accumulators.triggers
  
  ; update the rotating buffer timestamp with start_time
  rotating_buffer.timestamp += start_time

  return, rotating_buffer

end